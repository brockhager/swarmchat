name: Release / Build

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch: {}

jobs:
  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    env:
      TAURI_BUILD: true

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install dependencies
        run: npm ci

      - name: Prepare sidecar
        run: |
          echo "Preparing sidecar for runner: $RUNNER_OS"
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            powershell -c .\\scripts\\ci-copy-sidecar.ps1 -Target windows
          else
            bash ./scripts/ci-copy-sidecar.sh ${{ matrix.os }} || true
          fi

      - name: Build front-end
        run: npm run build || true

      - name: Tauri build
        uses: tauri-apps/tauri-action@v2
        with:
          release: true

      - name: "macOS: import signing certificate to keychain (if present)"
        if: ${{ matrix.os == 'macos-latest' && secrets.APPLE_CERT_P12 }}
        run: |
          echo "Found Apple certificate secret â€” installing into temporary keychain"
          echo "$APPLE_CERT_P12" | base64 --decode > /tmp/cert.p12
          KEYCHAIN_PASS="ci-$RANDOM"
          security create-keychain -p "$KEYCHAIN_PASS" build.keychain
          security import /tmp/cert.p12 -k build.keychain -P "$APPLE_CERT_PASSWORD" -A || true
          security list-keychains -s build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASS" build.keychain

      - name: "Windows: sign built installers (if present)"
        if: ${{ matrix.os == 'windows-latest' && secrets.WINDOWS_SIGN_CERT }}
        shell: powershell
        run: |
          $root = "${{ github.workspace }}"
          $pfxPath = Join-Path $root "src-tauri\sidecar\cert.pfx"
          $b64 = "${{ secrets.WINDOWS_SIGN_CERT }}"
          [System.IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($b64))
          Write-Host "Wrote PFX to $pfxPath"
          # install osslsigncode if missing (choco)
          choco install osslsigncode -y || Write-Host "osslsigncode may already be installed"
          # find MSI/EXE to sign
          $artifacts = Get-ChildItem -Path (Join-Path $root 'src-tauri\target\release\bundle') -Recurse -Include *.msi,*.exe | Select-Object -First 1
          if ($artifacts) {
            $file = $artifacts.FullName
            Write-Host "Signing $file with osslsigncode"
            osslsigncode sign -pkcs12 $pfxPath -pass "${{ secrets.WINDOWS_SIGN_CERT_PASSWORD }}" -n "SwarmChat" -t http://timestamp.digicert.com -in $file -out $file.signed || Write-Host "osslsigncode failed"
          } else {
            Write-Host "No MSI/EXE found to sign"
          }

      - name: List packaged artifacts (for debugging)
        run: |
          echo "--- bundle output ---"
          ls -la src-tauri/target/release/bundle || true

      - name: "macOS: Notarize DMG (if API key present)"
        if: ${{ matrix.os == 'macos-latest' && secrets.APPLE_API_KEY }}
        env:
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
        run: |
          set -e
          echo "Notarization step beginning (using Apple API Key)..."
          # Decode API key
          echo "$APPLE_API_KEY" | base64 --decode > /tmp/AuthKey_${APPLE_API_KEY_ID}.p8
          echo "Searching for dmg under src-tauri/target/release/bundle"
          DMG=$(find src-tauri/target/release/bundle -type f -name '*.dmg' | head -n 1 || true)
          if [ -z "$DMG" ]; then
            echo "No DMG found to notarize; skipping"
            exit 0
          fi
          echo "Found DMG: $DMG"
          # Submit for notarization and wait
          xcrun notarytool submit "$DMG" --key /tmp/AuthKey_${APPLE_API_KEY_ID}.p8 --key-id "$APPLE_API_KEY_ID" --issuer "$APPLE_API_ISSUER" --wait
          STATUS=$?
          if [ $STATUS -ne 0 ]; then
            echo "Notarization submission failed with status $STATUS" >&2
            exit $STATUS
          fi
          echo "Stapling notarization ticket to DMG"
          xcrun stapler staple "$DMG"
          echo "Validation of stapled DMG"
          xcrun stapler validate "$DMG" || true

      - name: Upload bundles as job artifact
        uses: actions/upload-artifact@v3
        with:
          name: bundle-${{ matrix.os }}
          path: src-tauri/target/release/bundle

  publish:
    name: Publish Release
    runs-on: ubuntu-latest
    needs: build
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          path: artifacts

      - name: Show files (debug)
        run: |
          pwd
          ls -la artifacts || true

      - name: Create GitHub Release and upload artifacts
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ github.ref_name }}
          files: artifacts/**

      - name: Notarize macOS artifact (if APPLE credentials present)
        if: ${{ secrets.APPLE_API_KEY || (secrets.APPLE_ID && secrets.APPLE_APP_SPECIFIC_PASSWORD) }}
        run: |
          echo "Notarization step requested. This workflow detects credentials and would submit the built macOS DMG for notarization if present."
          # This step assumes the DMG is available in artifacts/ from the matrix jobs and runner has xcrun available.
          # Use APPLE_API_KEY (base64 .p8), APPLE_API_KEY_ID, APPLE_API_ISSUER for notarytool, or APPLE_ID + APPLE_APP_SPECIFIC_PASSWORD for altool.
          echo "Ensure secrets.APPLE_API_KEY or APPLE_ID + APPLE_APP_SPECIFIC_PASSWORD are configured in repo settings."
