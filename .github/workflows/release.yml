name: Release / Build

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch: {}

permissions:
  contents: write
  packages: write
  actions: read

jobs:

  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    env:
      TAURI_BUILD: true
      # Optional: if you set a repository secret named SIDECAR_URL containing a public or authenticated
      # URL for the prebuilt Windows sidecar (dendrite-windows.exe), the workflow will download it into
      # src-tauri/sidecar/prebuilt so the packaging step can include a real binary.
      SIDECAR_URL: ${{ secrets.SIDECAR_URL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install dependencies
        run: npm ci

      - name: Prepare sidecar
        id: prepare_sidecar
        shell: bash
        run: |
          echo "Preparing sidecar for runner: $RUNNER_OS (matrix: ${{ matrix.os }})"
          # create directories we will use
          mkdir -p src-tauri/sidecar/prebuilt src-tauri/resources/sidecar

          # If a SIDECAR_URL is configured, attempt to download a platform-appropriate prebuilt into prebuilt/
          if [ -n "$SIDECAR_URL" ]; then
            echo "SIDECAR_URL present — trying to download into src-tauri/sidecar/prebuilt"
            if [ "${{ matrix.os }}" = "windows-latest" ]; then
              # On windows runner use PowerShell to download so we keep the .exe name
              pwsh -Command "try { Invoke-WebRequest -Uri '$SIDECAR_URL' -OutFile 'src-tauri/sidecar/prebuilt/dendrite-windows.exe' } catch { Write-Host 'Download failed' ; exit 0 }" || true
            elif [ "${{ matrix.os }}" = "macos-latest" ]; then
              curl -L -s -f -o src-tauri/sidecar/prebuilt/dendrite-macos "$SIDECAR_URL" || true
            else
              curl -L -s -f -o src-tauri/sidecar/prebuilt/dendrite-linux "$SIDECAR_URL" || true
            fi
          else
            echo "No SIDECAR_URL set — skipping download"
          fi

          # Copy available prebuilt for the current matrix target into resources/sidecar and set the output
          case "${{ matrix.os }}" in
            windows-latest)
              if [ -f src-tauri/sidecar/prebuilt/dendrite-windows.exe ]; then
                cp src-tauri/sidecar/prebuilt/dendrite-windows.exe src-tauri/resources/sidecar/dendrite.exe
                echo "has_sidecar=true" >> $GITHUB_OUTPUT
              else
                echo "No windows prebuilt found — continuing without sidecar"
                echo "has_sidecar=false" >> $GITHUB_OUTPUT
              fi
              ;;
            macos-latest)
              if [ -f src-tauri/sidecar/prebuilt/dendrite-macos ]; then
                cp src-tauri/sidecar/prebuilt/dendrite-macos src-tauri/resources/sidecar/dendrite
                chmod +x src-tauri/resources/sidecar/dendrite || true
                echo "has_sidecar=true" >> $GITHUB_OUTPUT
              else
                echo "No mac prebuilt found — continuing without sidecar"
                echo "has_sidecar=false" >> $GITHUB_OUTPUT
              fi
              ;;
            ubuntu-latest)
              if [ -f src-tauri/sidecar/prebuilt/dendrite-linux ]; then
                cp src-tauri/sidecar/prebuilt/dendrite-linux src-tauri/resources/sidecar/dendrite
                chmod +x src-tauri/resources/sidecar/dendrite || true
                echo "has_sidecar=true" >> $GITHUB_OUTPUT
              else
                echo "No linux prebuilt found — continuing without sidecar"
                echo "has_sidecar=false" >> $GITHUB_OUTPUT
              fi
              ;;
            *)
              echo "Unknown matrix.os; setting has_sidecar=false" >> $GITHUB_OUTPUT
              ;;
          esac
      - name: Verify injected sidecar (metadata + checksum)
        shell: bash
        run: |
          echo "Verifying sidecar metadata and checksum"
          case "${{ matrix.os }}" in
            windows-latest)
              if [ -f src-tauri/sidecar/prebuilt/dendrite-windows.exe ]; then
                pwsh -Command "Get-Item -Path src-tauri/sidecar/prebuilt/dendrite-windows.exe | Format-List Name,Length,LastWriteTime"
                pwsh -Command "Get-FileHash -Path src-tauri/sidecar/prebuilt/dendrite-windows.exe -Algorithm SHA256 | Format-List"
                # Attempt to run the binary with --version to verify it is executable
                pwsh -Command "try { & 'src-tauri/sidecar/prebuilt/dendrite-windows.exe' --version } catch { Write-Host 'Exe execution failed or returned non-zero' }"
              fi
              ;;
            macos-latest)
              if [ -f src-tauri/sidecar/prebuilt/dendrite-macos ]; then
                ls -l src-tauri/sidecar/prebuilt/dendrite-macos
                sh -c "sha256sum src-tauri/sidecar/prebuilt/dendrite-macos || true"
                sh -c "src-tauri/sidecar/prebuilt/dendrite-macos --version || true"
              fi
              ;;
            ubuntu-latest)
              if [ -f src-tauri/sidecar/prebuilt/dendrite-linux ]; then
                ls -l src-tauri/sidecar/prebuilt/dendrite-linux
                sh -c "sha256sum src-tauri/sidecar/prebuilt/dendrite-linux || true"
                sh -c "src-tauri/sidecar/prebuilt/dendrite-linux --version || true"
              fi
              ;;
            *)
              echo "no sidecar for this runner"
              ;;
          esac

      - name: Build front-end
        run: npm run build || true

      - name: Tauri build
        # Run Tauri build only on Windows runners (we produce a single NSIS .exe installer)
        if: ${{ matrix.os == 'windows-latest' && steps.prepare_sidecar.outputs.has_sidecar == 'true' }}
        uses: tauri-apps/tauri-action@action-v0.6.0
        with:
          # ensure the action runs against the tauri project under src-tauri and uses the project's CLI if present
          projectPath: src-tauri
          # Use npx to run the local @tauri-apps/cli v2 from node_modules (avoids global v1 CLI mismatch)
          tauriScript: npx @tauri-apps/cli
          # let the action perform a release build (includeRelease defaults to true); avoid using unsupported `release` input

      - name: "macOS: import signing certificate to keychain (if present)"
        if: ${{ matrix.os == 'macos-latest' }}
        env:
          APPLE_CERT_P12: ${{ secrets.APPLE_CERT_P12 }}
          APPLE_CERT_PASSWORD: ${{ secrets.APPLE_CERT_PASSWORD }}
        run: |
          if [ -z "$APPLE_CERT_P12" ]; then
            echo "No APPLE_CERT_P12 secret configured — skipping macOS signing step"
            exit 0
          fi
          echo "Found Apple certificate secret — installing into temporary keychain"
          echo "$APPLE_CERT_P12" | base64 --decode > /tmp/cert.p12
          KEYCHAIN_PASS="ci-$RANDOM"
          security create-keychain -p "$KEYCHAIN_PASS" build.keychain
          security import /tmp/cert.p12 -k build.keychain -P "$APPLE_CERT_PASSWORD" -A || true
          security list-keychains -s build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASS" build.keychain

      - name: "Windows: sign built installers (if present)"
        if: ${{ matrix.os == 'windows-latest' }}
        env:
          WINDOWS_SIGN_CERT: ${{ secrets.WINDOWS_SIGN_CERT }}
          WINDOWS_SIGN_CERT_PASSWORD: ${{ secrets.WINDOWS_SIGN_CERT_PASSWORD }}
        # use PowerShell core on Windows runners (pwsh) for modern shell behavior
        shell: pwsh
        run: |
          $root = "${{ github.workspace }}"
          $pfxPath = Join-Path $root "src-tauri\sidecar\cert.pfx"
          if (-not $env:WINDOWS_SIGN_CERT) {
            Write-Host "No WINDOWS_SIGN_CERT secret configured; skipping Windows signing"
            exit 0
          }
          $b64 = "${env:WINDOWS_SIGN_CERT}"
          [System.IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($b64))
          Write-Host "Wrote PFX to $pfxPath"
          # install osslsigncode if missing (choco); ignore non-zero exit codes (may already be present)
          try {
            choco install osslsigncode -y
          } catch {
            Write-Host "osslsigncode may already be installed or installation failed: $_"
          }
          # find MSI/EXE to sign
          $artifacts = Get-ChildItem -Path (Join-Path $root 'src-tauri\target\release\bundle') -Recurse -Include *.msi,*.exe | Select-Object -First 1
          if ($artifacts) {
            $file = $artifacts.FullName
            Write-Host "Signing $file with osslsigncode"
            try {
              & osslsigncode sign -pkcs12 $pfxPath -pass $env:WINDOWS_SIGN_CERT_PASSWORD -n "SwarmChat" -t http://timestamp.digicert.com -in $file -out "$file.signed"
              if ($LASTEXITCODE -ne 0) { Write-Host "osslsigncode sign returned exit code $LASTEXITCODE" }
            } catch {
              Write-Host "osslsigncode failed: $_"
            }
          } else {
            Write-Host "No MSI/EXE found to sign"
          }

      - name: List packaged artifacts (for debugging)
        shell: bash
        run: |
          echo "--- bundle output ---"
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            # Use PowerShell to list files on Windows
            pwsh -Command "if (Test-Path 'src-tauri/target/release/bundle') { Get-ChildItem -Path 'src-tauri/target/release/bundle' -Recurse -ErrorAction SilentlyContinue | Format-Table -AutoSize }"
          else
            ls -la src-tauri/target/release/bundle || true
          fi

      - name: "macOS: Notarize DMG (if API key present)"
        if: ${{ matrix.os == 'macos-latest' }}
        env:
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
        run: |
          set -e
          if [ -z "$APPLE_API_KEY" ]; then
            echo "No APPLE_API_KEY configured — skipping notarization step"
            exit 0
          fi
          echo "Notarization step beginning (using Apple API Key)..."
          # Decode API key
          echo "$APPLE_API_KEY" | base64 --decode > /tmp/AuthKey_${APPLE_API_KEY_ID}.p8
          echo "Searching for dmg under src-tauri/target/release/bundle"
          DMG=$(find src-tauri/target/release/bundle -type f -name '*.dmg' | head -n 1 || true)
          if [ -z "$DMG" ]; then
            echo "No DMG found to notarize; skipping"
            exit 0
          fi
          echo "Found DMG: $DMG"
          # Submit for notarization and wait
          xcrun notarytool submit "$DMG" --key /tmp/AuthKey_${APPLE_API_KEY_ID}.p8 --key-id "$APPLE_API_KEY_ID" --issuer "$APPLE_API_ISSUER" --wait
          STATUS=$?
          if [ $STATUS -ne 0 ]; then
            echo "Notarization submission failed with status $STATUS" >&2
            exit $STATUS
          fi
          echo "Stapling notarization ticket to DMG"
          xcrun stapler staple "$DMG"
          echo "Validation of stapled DMG"
          xcrun stapler validate "$DMG" || true

      - name: Upload bundles as job artifact
        uses: actions/upload-artifact@v4
        with:
          name: bundle-${{ matrix.os }}
          path: src-tauri/target/release/bundle

  publish:
    name: Publish Release
    runs-on: ubuntu-latest
    needs: build
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Show files (debug)
        run: |
          pwd
          ls -la artifacts || true

      - name: Create GitHub Release and upload artifacts
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ github.ref_name }}
          artifacts: artifacts/**
          token: ${{ secrets.GITHUB_TOKEN }}
          allowUpdates: true
          updateOnlyUnreleased: false

      - name: Notarize macOS artifact (if APPLE credentials present)
        # run on publish job but perform credential checks inside the step to avoid workflow validation errors
        if: ${{ always() }}
        env:
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          if [ -z "$APPLE_API_KEY" -a -z "$APPLE_ID" ]; then
            echo "No Apple notarization credentials found — skipping notarization"
            exit 0
          fi
          echo "Notarization step requested. This workflow detects credentials and would submit the built macOS DMG for notarization if present."
          # This step assumes the DMG is available in artifacts/ from the matrix jobs and runner has xcrun available.
          # Use APPLE_API_KEY (base64 .p8), APPLE_API_KEY_ID, APPLE_API_ISSUER for notarytool, or APPLE_ID + APPLE_APP_SPECIFIC_PASSWORD for altool.
          echo "Ensure secrets.APPLE_API_KEY or APPLE_ID + APPLE_APP_SPECIFIC_PASSWORD are configured in repo settings."
